esphome:
  name: esp32_epaper
  platform: ESP32
  board: esp32dev
  includes:
    - libraries/icon-map.h
    - libraries/GY-49.h
  libraries:
    - "Max44009"

wifi:
  ssid: ********
  password: *****
  
  manual_ip:
    static_ip: 192.168.0.18
    gateway: 192.168.0.1
    subnet: 255.255.255.0

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Esp32 Epaper Fallback Hotspot"
    password: "kwSq3sc56LSc"

captive_portal:

# Enable logging
logger:

# Enable Home Assistant API
api:

ota:

# esp32_ble_tracker:

i2c:
  sda: 21
  scl: 22

time:
  - platform: homeassistant
    id: esptime
    
binary_sensor:
  - platform: gpio
    name: "${device_name}_sw1"
    id: epaper_sw1 
    pin: 
      number: GPIO39
      mode: INPUT_PULLUP
      inverted: True
    filters:
        - delayed_on: 5ms
    on_click:
      min_length: 50ms
      max_length: 350ms
      then:
        - if:
            condition:
              - light.is_off:
                  id: epaper_led
            then:
              - light.turn_on:
                  id: epaper_led
                  brightness: 80%
            else:
              - light.turn_off: epaper_led
              
sensor:
  # - platform: xiaomi_hhccjcy01
  #   mac_address: "C4:7C:8D:6B:50:B2"
  #   id: "plant"
  #   temperature:
  #     name: "Temperature"
  #     id: "temp"
  #   moisture:
  #     name: "Moisture"
  #     id: "moist"
  #   illuminance:
  #     name: "Illuminance"
  #     id: "illum"
  #   conductivity:
  #     name: "Conductivity"
  #     id: "cond"

  - platform: uptime
    name: "${device_name} Uptime Sec"
    id: uptime_sec
    internal: true

  - platform: wifi_signal
    id: wifi_strength
    name: "${device_name} WiFi Signal"
    update_interval: 360s

  - platform: adc
    pin: GPIO35
    id: "VCC"
    internal: true
    # Max Vcc: 1.1 0db, 1.5 2.5db, 2.2V 6db, 3.9V 11db
    attenuation: 11db
    update_interval: 60s
    # Voltage divider on VCC to GPIO35 R1=R2=100k 1:2
    filters:
      - multiply: 1.796
    accuracy_decimals: 5
    unit_of_measurement: V

  - platform: bmp280
    temperature:
      name: "BMP280 Temperature"
      oversampling: 16x
      id: "temp"
    pressure:
      name: "BMP280 Pressure"
      id: "press"
    address: 0x76
    update_interval: 60s

  - platform: custom
    lambda: |-
      auto lux_sensor = new MAX44009Sensor();
      App.register_component(lux_sensor);
      return {lux_sensor};
  
    sensors:
      name: "GY-49"
      unit_of_measurement: lx
      id: "illum"

  - platform: adc
    pin: A0
    name: "Soil Moisture"
    id : "Soil_capacitance"
    update_interval: 10s
    unit_of_measurement: "%"
    attenuation: 11db
    filters:
    - median:
        window_size: 7
        send_every: 4
        send_first_at: 1
    - calibrate_linear:
        - 1.25 -> 100.00
        - 2.8 -> 0.00
    - lambda: if (x < 1) return 0; else if (x > 100) return 100; return (x);
    accuracy_decimals: 0
    
  - platform: template
    name: "${device_name} Battery"
    id: "battery"
    unit_of_measurement: "%"
    update_interval: 60s
    # vmin 3.5 vmax 4.2
    lambda: |-
      float battery_perc = 100.00 * (id(VCC).state - 3.5) / (4.20-3.5);
      return (battery_perc > 100.0) ? 100.0 : battery_perc ;



text_sensor:
  - platform: version
    name: "${device_name} Version"

  - platform: wifi_info
    ip_address:
      name: "${device_name} IPv4"
      icon: "mdi:server-network"
    ssid:
      name: "${device_name} Connected SSID"
      icon: "mdi:wifi"

  - platform: template
    name: "${device_name} Uptime"
    icon: "mdi:timer"
    update_interval: 360s
    lambda: |-
      int seconds = id(uptime_sec).state;
      int days = seconds / (24 * 3600);
      seconds = seconds % (24 * 3600); 
      int hours = seconds / 3600;
      seconds = seconds % 3600;
      int minutes = seconds /  60;
      return { (String(days) +"d " + String(hours) +"h " + String(minutes) +"m").c_str() };

  - platform: homeassistant
    id: icon_ow
    entity_id:  weather.openweathermap

output:
  - platform: ledc
    pin: GPIO19
    id: gpio_19

light:
  - platform: monochromatic
    output: gpio_19
    name: "epaper_led"
    id: epaper_led    
# see https://community.home-assistant.io/t/display-materialdesign-icons-on-esphome-attached-to-screen/199790/16
# see https://cdn.materialdesignicons.com/4.7.95/
image:
  - file: "image.png"
    id: image1
  - file: "Basil_label_1.png"
    id: background_image

font:
  - file: "fonts/Audiowide.ttf"
    id: font_title
    size: 20
  - file: "fonts/Audiowide.ttf"
    id: font_subtitle
    size: 15
  - file: "fonts/Audiowide.ttf"
    id: font_parameters
    size: 12
  - file: 'fonts/materialdesignicons-webfont_5.9.55.ttf'
    id: font_icon_battery
    size: 20
    glyphs:
      - "\U000F007A" # battery-10
      - "\U000F007B" # battery-20
      - "\U000F007C" # battery-30
      - "\U000F007D" # battery-40
      - "\U000F007E" # battery-50
      - "\U000F007F" # battery-60
      - "\U000F0080" # battery-70
      - "\U000F0081" # battery-80
      - "\U000F0082" # battery-90
      - "\U000F0079" # battery
      - "\U000F0083" # battery-alert
      - "\U000F10CC" # battery-alert-variant
      - "\U000F10CD" # battery-alert-variant-outline
      - "\U000F010C" # mdi-car-battery
      - "\U000F092D" # wifi-off
      - "\U000F092E" # wifi-strength-0
      - "\U000F091F" # wifi-strength-1
      - "\U000F0922" # wifi-strength-2
      - "\U000F0925" # wifi-strength-3
      - "\U000F0928" # wifi-strength-4
      - "\U000F04E6" # sync

  - file: 'fonts/materialdesignicons-webfont.ttf'
    id: font_icon_big
    size: 80
    glyphs:
      - "\U000F0590" # weather-cloudy
      - "\U000F0F2F" # weather-cloudy-alert
      - "\U000F0E6E" # weather-cloudy-arrow-right
      - "\U000F0591" # weather-fog
      - "\U000F0592" # weather-hail
      - "\U000F0F30" # weather-hazy
      - "\U000F0898" # weather-hurricane
      - "\U000F0593" # weather-lightning
      - "\U000F067E" # weather-lightning-rainy
      - "\U000F0594" # weather-night
      - "\U000F0F31" # weather-night-partly-cloudy
      - "\U000F0595" # weather-partly-cloudy
      - "\U000F0F32" # weather-partly-lightning
      - "\U000F0F33" # weather-partly-rainy
      - "\U000F0F34" # weather-partly-snowy
      - "\U000F0F35" # weather-partly-snowy-rainy
      - "\U000F0596" # weather-pouring
      - "\U000F0597" # weather-rainy
      - "\U000F0598" # weather-snowy
      - "\U000F0F36" # weather-snowy-heavy
      - "\U000F067F" # weather-snowy-rainy
      - "\U000F0599" # weather-sunny
      - "\U000F0F37" # weather-sunny-alert
      - "\U000F14E4" # weather-sunny-off
      - "\U000F059A" # weather-sunset
      - "\U000F059B" # weather-sunset-down
      - "\U000F059C" # weather-sunset-up
      - "\U000F0F38" # weather-tornado
      - "\U000F059D" # weather-windy
      - "\U000F059E" # weather-windy-variant
spi:
  clk_pin:  GPIO18
  mosi_pin: GPIO23

display:
  - platform: waveshare_epaper
  #- platform: gxepd2_epaper
    dc_pin: GPIO17
    cs_pin: GPIO5
    busy_pin: GPIO4
    reset_pin: GPIO16
    rotation: 270
    model: 2.13in-ttgo-b74
    update_interval: 60s
    full_update_every: 30
    id: my_display
    #info pixel dimensions: 250x122px
    #  #  line( x_1, y_1, x_2, y_2)
    #  HORIZ (90) 0 <= x <= 249, 6 <= y <= 127
    lambda: |-
        #define H_LEFT_MARGIN 4
        #define H_RIGHT_MARGIN 240
        #define H_CENTER 128 
        #define V_WEATHER 0
        #define V_CLOCK 1
        #define V_WIFI 30
        #define V_VOLTAGE 60
        #define V_BATTERY  90
        
        it.image(0, 0, id(background_image));
        
        // Battery
        float battery_perc = 100.00 * (id(VCC).state - 3.5) / (4.20-3.5);
        int battery_range = battery_perc / 10 ;
        battery_range = (battery_range > 10) ? 10 : battery_range;
        battery_range = (battery_range < 0)  ?  0 : battery_range;
        
        it.printf(233, 1, id(font_icon_battery), TextAlign::TOP_LEFT, 
        battery_icon_map[battery_range].c_str()
        );
        it.printf(233, 1, id(font_subtitle), TextAlign::TOP_RIGHT, 
        "%3.0f%%", battery_perc);
        //it.line(  0,    0,   0, 249);
        //it.line( 121,   0, 121, 249);
        //it.line(   0,   0, 121,   0);
        //it.line(   0, 249, 121, 249);   
        
        // Clock 
        it.strftime(233, 18, id(font_subtitle), TextAlign::TOP_RIGHT, 
        "%d/%m", id(esptime).now());     
        
        // Parameters
        
        // Printing the value
        //float conductivity = id(cond).state / 1000;
        
        it.printf(115, 75, id(font_parameters), TextAlign::TOP_CENTER, 
        "%.0f%%", id(Soil_capacitance).state);  
        it.printf(152, 105, id(font_parameters), TextAlign::TOP_CENTER, 
        "%.0flx", id(illum).state);  
        it.printf(188, 75, id(font_parameters), TextAlign::TOP_CENTER, 
        "%.1fÂ°C", id(temp).state);     
        it.printf(225, 105, id(font_parameters), TextAlign::TOP_CENTER, 
        "%.0fhPa", id(press).state);  
        //it.printf(240, 124, id(font_parameters), TextAlign::BOTTOM_RIGHT, "cm"); 
        
        // Drawing the marker over the gauge
        float pi = 3.141592653589793;
        float alpha = 4.71238898038469; // Defined as the gauge angle in radians (270deg)
        float beta = 2*pi - alpha;
        int radius = 15;              // Radius of the gauge in pixels
        int thick = 5;                // Size of the marker 
        
        // *** Moisture ***
        int min_range = 0; 
        int max_range = 100;
        int xc = 100;
        int yc = 50;
        
        float measured = id(Soil_capacitance).state;
        
        if (measured < min_range) {
          measured = min_range;
        } 
        if (measured > max_range) {
          measured = max_range;
        } 
        
        float val = (measured - min_range) / abs(max_range - min_range) * alpha;
        
        int x0 = static_cast<int>(xc + radius + radius * cos(pi / 2 + beta / 2 + val));
        int y0 = static_cast<int>(yc + radius + radius * sin(pi / 2 + beta / 2 + val));
        int x1 = static_cast<int>(xc + radius + (radius+thick) * cos(pi / 2 + beta / 2 + val + 0.1));
        int y1 = static_cast<int>(yc + radius + (radius+thick) * sin(pi / 2 + beta / 2 + val + 0.1));
        int x2 = static_cast<int>(xc + radius + (radius+thick) * cos(pi / 2 + beta / 2 + val - 0.1));
        int y2 = static_cast<int>(yc + radius + (radius+thick) * sin(pi / 2 + beta / 2 + val - 0.1));
        it.line(x0, y0, x1, y1);
        it.line(x1, y1, x2, y2);
        it.line(x2, y2, x0, y0);
        
        // *** Light ***
        min_range = 0; 
        max_range = 10000;
        xc = 137;
        yc = 80;
        
        measured = id(illum).state;
        
        if (measured < min_range) {
          measured = min_range;
        } 
        if (measured > max_range) {
          measured = max_range;
        } 
        
        val = (measured - min_range) / abs(max_range - min_range) * alpha;        
        x0 = static_cast<int>(xc + radius + radius * cos(pi / 2 + beta / 2 + val));
        y0 = static_cast<int>(yc + radius + radius * sin(pi / 2 + beta / 2 + val));
        x1 = static_cast<int>(xc + radius + (radius+thick) * cos(pi / 2 + beta / 2 + val + 0.1));
        y1 = static_cast<int>(yc + radius + (radius+thick) * sin(pi / 2 + beta / 2 + val + 0.1));
        x2 = static_cast<int>(xc + radius + (radius+thick) * cos(pi / 2 + beta / 2 + val - 0.1));
        y2 = static_cast<int>(yc + radius + (radius+thick) * sin(pi / 2 + beta / 2 + val - 0.1));
        it.line(x0, y0, x1, y1);
        it.line(x1, y1, x2, y2);
        it.line(x2, y2, x0, y0);
        
        // *** Temperature ***
        min_range = -10; 
        max_range = 50;
        xc = 173;
        yc = 50;
        
        measured = id(temp).state;
        
        if (measured < min_range) {
          measured = min_range;
        } 
        if (measured > max_range) {
          measured = max_range;
        } 
        
        val = (measured - min_range) / abs(max_range - min_range) * alpha;        
        x0 = static_cast<int>(xc + radius + radius * cos(pi / 2 + beta / 2 + val));
        y0 = static_cast<int>(yc + radius + radius * sin(pi / 2 + beta / 2 + val));
        x1 = static_cast<int>(xc + radius + (radius+thick) * cos(pi / 2 + beta / 2 + val + 0.1));
        y1 = static_cast<int>(yc + radius + (radius+thick) * sin(pi / 2 + beta / 2 + val + 0.1));
        x2 = static_cast<int>(xc + radius + (radius+thick) * cos(pi / 2 + beta / 2 + val - 0.1));
        y2 = static_cast<int>(yc + radius + (radius+thick) * sin(pi / 2 + beta / 2 + val - 0.1));
        it.line(x0, y0, x1, y1);
        it.line(x1, y1, x2, y2);
        it.line(x2, y2, x0, y0);
        
        // *** Fertility *** (Or pressure until fertility)
        min_range = 900; 
        max_range = 1100;
        xc = 210;
        yc = 80;
        
        measured = id(press).state;
        
        if (measured < min_range) {
          measured = min_range;
        } 
        if (measured > max_range) {
          measured = max_range;
        } 
        
        val = (measured - min_range) / abs(max_range - min_range) * alpha;        
        x0 = static_cast<int>(xc + radius + radius * cos(pi / 2 + beta / 2 + val));
        y0 = static_cast<int>(yc + radius + radius * sin(pi / 2 + beta / 2 + val));
        x1 = static_cast<int>(xc + radius + (radius+thick) * cos(pi / 2 + beta / 2 + val + 0.1));
        y1 = static_cast<int>(yc + radius + (radius+thick) * sin(pi / 2 + beta / 2 + val + 0.1));
        x2 = static_cast<int>(xc + radius + (radius+thick) * cos(pi / 2 + beta / 2 + val - 0.1));
        y2 = static_cast<int>(yc + radius + (radius+thick) * sin(pi / 2 + beta / 2 + val - 0.1));
        it.line(x0, y0, x1, y1);
        it.line(x1, y1, x2, y2);
        it.line(x2, y2, x0, y0);
        
        
      #  // Weather icon
      #  it.printf( H_RIGHT_MARGIN ,  V_CLOCK, id(font_icon_big), TextAlign::TOP_CENTER, 
      #     weather_icon_map[id(icon_ow).state.c_str()].c_str());
          
      #  // Clock 
      #  it.strftime(H_LEFT_MARGIN, V_CLOCK, id(font_clock), TextAlign::TOP_LEFT, 
      #     "%H:%M", id(esptime).now());
          
      #  // Wifi   
      #  int wifi_bars = -1;
      #  float wifi_rssi = id(wifi_strength).state; 
      #  if (wifi_rssi > -50) {
      #     wifi_bars = 4;
      #  } else if (wifi_rssi > -60) {
      #     wifi_bars = 3;
      #  } else if (wifi_rssi > -70) {
      #     wifi_bars = 2;
      #  } else if (wifi_rssi > -80) {
      #     wifi_bars = 1;
      #  } else if (wifi_rssi > -90) {
      #     wifi_bars = 0;
      #  }

      #  it.printf( H_LEFT_MARGIN, V_WIFI, id(font_icon_battery), TextAlign::TOP_LEFT, 
      #     wifi_icon_map[wifi_bars].c_str());
      #  it.printf( H_RIGHT_MARGIN, V_WIFI, id(font_big), TextAlign::TOP_RIGHT, 
      #     "%3.0fdB", wifi_rssi);
       
      #  // Voltage 
      #  it.printf( H_LEFT_MARGIN, V_VOLTAGE +2, id(font_icon_battery), TextAlign::TOP_LEFT, 
      #     "\U000F010C");
      #  it.printf(H_RIGHT_MARGIN, V_VOLTAGE , id(font_big), TextAlign::TOP_RIGHT, 
      #     "%.2fV", id(VCC).state);


# deep_sleep:
#   run_duration: 8s
#   sleep_duration: 60s
#   wakeup_pin:
#     number: GPIO39
#     inverted: True
#   wakeup_pin_mode: IGNORE
#   id: deep_sleep_1